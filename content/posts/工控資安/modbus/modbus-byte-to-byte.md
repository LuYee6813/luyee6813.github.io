---
title: "Modbus TCP 手把手解析教學"
date: 2025-07-24
categories: [工控資安]
tags: [modbus]
---

# Modbus TCP 手把手解析教學

## 1. Modbus TCP 協議概述

Modbus TCP 是基於乙太網的 Modbus 協議變體，它在傳統的 Modbus 協議基礎上增加了 TCP/IP 網路支援。相比於 Modbus RTU/ASCII，Modbus TCP 具有以下特點：

- **傳輸層**：使用 TCP 協議，預設埠號 502
- **無需校驗**：TCP 本身提供可靠傳輸，無需額外的 CRC 校驗
- **網路化**：支援多個客戶端同時連接
- **更大的資料量**：支援更大的資料封包

## 2. Modbus TCP 連線建立過程

### 2.1 TCP 三次握手

在 Modbus 通訊開始前，首先需要建立 TCP 連線：

```
客戶端                    伺服器 (Port 502)
   |                          |
   |------> SYN ------------->|  (1) 客戶端發起連線請求
   |                          |
   |<--- SYN + ACK ----------|  (2) 伺服器回應並確認
   |                          |
   |------> ACK ------------->|  (3) 客戶端確認連線建立
   |                          |
   |==== TCP 連線建立 ====|
```

### 2.2 Modbus 會話建立

TCP 連線建立後，就可以開始 Modbus 通訊：

```
客戶端                    伺服器
   |                          |
   |--- Modbus Request ------>|  讀取/寫入請求
   |                          |
   |<-- Modbus Response ------|  回應資料或錯誤
   |                          |
```

## 3. Modbus TCP 封包結構

### 3.1 完整封包格式

```
+---+---+---+---+---+---+---+---+---+---+---+---+
| MBAP Header (7 bytes)     | PDU (1-253 bytes) |
+---+---+---+---+---+---+---+---+---+---+---+---+
```

### 3.2 MBAP (Modbus Application Protocol) Header

MBAP Header 固定為 7 個位元組：

```
+--------+--------+--------+--------+--------+--------+--------+
| Transaction ID | Protocol ID    | Length         | Unit ID|
|   (2 bytes)    |   (2 bytes)    |   (2 bytes)    |(1 byte)|
+--------+--------+--------+--------+--------+--------+--------+
   0-1        2-3        4-5          6
```

#### 各欄位詳細說明：

| 欄位               | 長度    | 說明                                     |
| ------------------ | ------- | ---------------------------------------- |
| **Transaction ID** | 2 bytes | 交易識別碼，用於配對請求和回應           |
| **Protocol ID**    | 2 bytes | 協議識別碼，Modbus TCP 固定為 0x0000     |
| **Length**         | 2 bytes | 後續位元組數量 (Unit ID + PDU 長度)      |
| **Unit ID**        | 1 byte  | 單元識別碼，在 TCP 中通常為 0x01 或 0xFF |

### 3.3 PDU (Protocol Data Unit)

PDU 包含功能碼和資料：

```
+--------+--------+--------+--------+
|Function|     Data Fields         |
| Code   |                         |
|(1 byte)|    (0-252 bytes)        |
+--------+--------+--------+--------+
```

## 4. 常用功能碼詳解

### 4.1 讀取功能碼

| 功能碼 | 名稱                   | 說明                    |
| ------ | ---------------------- | ----------------------- |
| 0x01   | Read Coils             | 讀取線圈狀態 (離散輸出) |
| 0x02   | Read Discrete Inputs   | 讀取離散輸入            |
| 0x03   | Read Holding Registers | 讀取保持暫存器          |
| 0x04   | Read Input Registers   | 讀取輸入暫存器          |

### 4.2 寫入功能碼

| 功能碼 | 名稱                     | 說明           |
| ------ | ------------------------ | -------------- |
| 0x05   | Write Single Coil        | 寫入單個線圈   |
| 0x06   | Write Single Register    | 寫入單個暫存器 |
| 0x0F   | Write Multiple Coils     | 寫入多個線圈   |
| 0x10   | Write Multiple Registers | 寫入多個暫存器 |

## 5. 實際封包範例解析

### 5.1 讀取保持暫存器範例

**請求封包** (讀取從地址 0x0000 開始的 10 個保持暫存器)：

```
Hex: 00 01 00 00 00 06 01 03 00 00 00 0A

解析：
┌────────┬────────┬────────┬────────┬────────┬────────┬────────┐
│ 00 01  │ 00 00  │ 00 06  │   01   │   03   │ 00 00  │ 00 0A  │
└────────┴────────┴────────┴────────┴────────┴────────┴────────┘
   Trans    Proto    Length   Unit    Func    Start     Qty
    ID       ID                ID     Code    Addr
```

**詳細解析：**

- `00 01`: Transaction ID = 1
- `00 00`: Protocol ID = 0 (Modbus TCP)
- `00 06`: Length = 6 (Unit ID + Function Code + Start Address + Quantity)
- `01`: Unit ID = 1
- `03`: Function Code = 0x03 (Read Holding Registers)
- `00 00`: Starting Address = 0
- `00 0A`: Quantity = 10 registers

**回應封包**：

```
Hex: 00 01 00 00 00 17 01 03 14 00 64 00 C8 01 2C 01 90 01 F4 02 58 02 BC 03 20

解析：
┌────────┬────────┬────────┬────────┬────────┬────────┬──────────────────────┐
│ 00 01  │ 00 00  │ 00 17  │   01   │   03   │   14   │    Register Data     │
└────────┴────────┴────────┴────────┴────────┴────────┴──────────────────────┘
   Trans    Proto    Length   Unit    Func    Byte           (20 bytes)
    ID       ID                ID     Code    Count
```

**資料解析：**

- `14`: Byte Count = 20 bytes (10 registers × 2 bytes each)
- Register 0: `00 64` = 100
- Register 1: `00 C8` = 200
- Register 2: `01 2C` = 300
- Register 3: `01 90` = 400
- Register 4: `01 F4` = 500
- Register 5: `02 58` = 600
- Register 6: `02 BC` = 700
- Register 7: `03 20` = 800
- Register 8: `03 84` = 900
- Register 9: `03 E8` = 1000

### 5.2 寫入單個線圈範例

**請求封包** (設定地址 0x0001 的線圈為 ON)：

```
Hex: 00 02 00 00 00 06 01 05 00 01 FF 00

解析：
┌────────┬────────┬────────┬────────┬────────┬────────┬────────┐
│ 00 02  │ 00 00  │ 00 06  │   01   │   05   │ 00 01  │ FF 00  │
└────────┴────────┴────────┴────────┴────────┴────────┴────────┘
   Trans    Proto    Length   Unit    Func    Coil     Value
    ID       ID                ID     Code    Addr
```

**詳細解析：**

- `00 02`: Transaction ID = 2
- `00 00`: Protocol ID = 0
- `00 06`: Length = 6
- `01`: Unit ID = 1
- `05`: Function Code = 0x05 (Write Single Coil)
- `00 01`: Coil Address = 1
- `FF 00`: Value = ON (0xFF00 = ON, 0x0000 = OFF)

**回應封包** (正常情況下與請求相同)：

```
Hex: 00 02 00 00 00 06 01 05 00 01 FF 00
```

### 5.3 錯誤回應範例

當發生錯誤時，伺服器會回傳錯誤封包：

```
Hex: 00 01 00 00 00 03 01 83 02

解析：
┌────────┬────────┬────────┬────────┬────────┬────────┐
│ 00 01  │ 00 00  │ 00 03  │   01   │   83   │   02   │
└────────┴────────┴────────┴────────┴────────┴────────┘
   Trans    Proto    Length   Unit    Error   Except
    ID       ID                ID     Code    Code
```

**詳細解析：**

- `83`: Error Function Code = 0x83 (0x03 + 0x80)
- `02`: Exception Code = 0x02 (Illegal Data Address)

## 6. 異常碼對照表

| 異常碼 | 名稱                     | 說明               |
| ------ | ------------------------ | ------------------ |
| 0x01   | Illegal Function         | 不支援的功能碼     |
| 0x02   | Illegal Data Address     | 無效的資料地址     |
| 0x03   | Illegal Data Value       | 無效的資料值       |
| 0x04   | Slave Device Failure     | 從屬設備故障       |
| 0x05   | Acknowledge              | 確認 (長時間操作)  |
| 0x06   | Slave Device Busy        | 從屬設備忙碌       |
| 0x08   | Memory Parity Error      | 記憶體奇偶校驗錯誤 |
| 0x0A   | Gateway Path Unavailable | 閘道路徑不可用     |
| 0x0B   | Gateway Target Failed    | 閘道目標回應失敗   |

## 7. 資料型別和地址空間

### 7.1 Modbus 資料模型

Modbus 定義了四種不同的資料區域：

| 資料類型          | 地址範圍    | 存取權限 | 資料大小 | 說明         |
| ----------------- | ----------- | -------- | -------- | ------------ |
| Coils             | 00001-09999 | 讀/寫    | 1 bit    | 離散輸出線圈 |
| Discrete Inputs   | 10001-19999 | 唯讀     | 1 bit    | 離散輸入     |
| Input Registers   | 30001-39999 | 唯讀     | 16 bit   | 輸入暫存器   |
| Holding Registers | 40001-49999 | 讀/寫    | 16 bit   | 保持暫存器   |

### 7.2 地址計算

在 Modbus TCP 中，實際傳輸的地址是以 0 為基礎：

```
Modbus 地址 40001 → PDU 地址 0x0000
Modbus 地址 40002 → PDU 地址 0x0001
Modbus 地址 40010 → PDU 地址 0x0009
```

## 8. 實作注意事項

### 8.1 連線管理

- TCP 連線可以保持開啟，支援多個請求
- 建議實作連線超時機制
- 處理連線中斷和重連

### 8.2 Transaction ID 管理

- 每個請求應使用唯一的 Transaction ID
- 客戶端需要匹配請求和回應的 Transaction ID
- 可以使用遞增計數器或隨機數

### 8.3 錯誤處理

- 檢查回應的功能碼是否為錯誤碼 (0x80+)
- 處理網路超時和連線錯誤
- 實作重試機制

### 8.4 效能最佳化

- 批次讀取/寫入以減少網路往返
- 使用適當的超時設定
- 考慮使用連線池

## 9. 常見 Modbus TCP 攻擊方式

### 9.1 堆疊溢位攻擊 (Stack Overflow)

#### 9.1.1 攻擊原理

堆疊溢位攻擊利用目標系統對輸入資料長度檢查不足的漏洞，發送超長的 Modbus TCP 封包來覆蓋堆疊記憶體。

#### 9.1.2 攻擊範例

**正常封包**：

```
00 01 00 00 00 06 01 03 00 00 00 0A
```

**攻擊封包** (過長的 Transaction ID 填充)：

```
41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41
41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41
00 00 00 06 01 03 00 00 00 0A
```

#### 9.1.3 攻擊效果

- 造成程式當機或重啟
- 可能執行任意程式碼
- 破壞系統穩定性

#### 9.1.4 防護措施

- 嚴格檢查輸入資料長度
- 使用安全的程式語言和編譯器
- 實作堆疊保護機制
- 定期更新韌體

### 9.2 長度欄位操控攻擊 (Length Field Manipulation)

#### 9.2.1 攻擊原理

通過修改 MBAP Header 中的 Length 欄位，使其與實際載荷不符，導致解析錯誤或緩衝區溢位。

#### 9.2.2 攻擊範例

**Length 欄位過大**：

```
00 01 00 00 FF FF 01 03 00 00 00 0A
            ↑ ↑
        Length = 65535 (實際只有 6 bytes)
```

**Length 欄位過小**：

```
00 01 00 00 00 02 01 03 00 00 00 0A 41 41 41 41
            ↑ ↑                    ↑ ↑ ↑ ↑
        Length = 2              額外資料
```

#### 9.2.3 攻擊效果

- 造成解析器混亂
- 緩衝區溢位
- 資料洩漏
- 拒絕服務攻擊

#### 9.2.4 防護措施

- 嚴格驗證 Length 欄位
- 設定最大封包大小限制
- 實作安全的封包解析器

### 9.3 載荷注入攻擊 (Payload Injection)

#### 9.3.1 攻擊原理

在合法的 Modbus 請求中注入惡意載荷，利用目標系統的解析漏洞執行未授權操作。

#### 9.3.2 攻擊範例

**SQL 注入風格的攻擊**：

```
// 在寫入暫存器值中注入特殊字元
00 01 00 00 00 09 01 06 00 01 27 3B 44 52 4F 50
                                  ↑ ↑ ↑ ↑ ↑ ↑
                                '; DROP TABLE
```

**命令注入**：

```
// 在設備識別字串中注入系統命令
00 01 00 00 00 15 01 2B 0E 01 00 7C 72 6D 20 2D 72 66 20 2F 2A
                                   |rm -rf /*
```

#### 9.3.3 攻擊效果

- 執行未授權的系統命令
- 資料庫操作
- 檔案系統破壞
- 設備配置篡改

#### 9.3.4 防護措施

- 輸入驗證和過濾
- 參數化查詢
- 最小權限原則
- 沙箱執行環境

### 9.4 功能碼濫用攻擊 (Function Code Abuse)

#### 9.4.1 攻击原理

使用非標準或未授權的功能碼來探測系統功能或觸發意外行為。

#### 9.4.2 攻擊範例

**診斷功能濫用**：

```
00 01 00 00 00 06 01 08 00 00 A5 37
                   ↑
              診斷功能碼 (0x08)
```

**廠商專用功能碼**：

```
00 01 00 00 00 03 01 65 00
                   ↑
              廠商自定義功能碼 (0x65)
```

#### 9.4.3 攻擊效果

- 資訊洩漏
- 設備重啟
- 配置重置
- 未記錄的功能執行

#### 9.4.4 防護措施

- 功能碼白名單
- 存取控制清單
- 功能稽核日誌

### 9.5 洪水攻擊 (Flooding Attack)

#### 9.5.1 攻擊原理

大量發送 Modbus TCP 請求來耗盡目標資源，造成拒絕服務。

#### 9.5.2 攻击範例

**連線洪水**：

```python
# 偽代碼
for i in range(10000):
    socket.connect(target, 502)
    socket.send(modbus_request)
```

**請求洪水**：

```python
# 偽代碼
while True:
    for tid in range(65536):
        send_modbus_request(tid, random_function_code)
```

#### 9.5.3 攻擊效果

- 系統資源耗盡
- 服務無法回應
- 網路頻寬飽和
- 合法使用者無法存取

#### 9.5.4 防護措施

- 連線數量限制
- 請求速率限制
- 防火牆規則
- 入侵偵測系統

### 9.6 Man-in-the-Middle 攻擊

#### 9.6.1 攻擊原理

攻擊者位於客戶端和伺服器之間，攔截、修改或重放 Modbus 通訊。

#### 9.6.2 攻擊範例

**封包攔截與修改**：

```
原始請求: 00 01 00 00 00 06 01 05 00 01 FF 00 (設定線圈為 ON)
修改後:   00 01 00 00 00 06 01 05 00 01 00 00 (設定線圈為 OFF)
```

**重放攻擊**：

```
// 記錄合法的寫入操作
00 01 00 00 00 09 01 10 00 00 00 02 04 03 E8 07 D0

// 稍後重放相同操作
00 01 00 00 00 09 01 10 00 00 00 02 04 03 E8 07 D0
```

#### 9.6.3 攻擊效果

- 資料竊取
- 操作篡改
- 身份冒充
- 系統控制

#### 9.6.4 防護措施

- 加密通訊 (TLS)
- 訊息認證碼 (MAC)
- 時間戳驗證
- 網路分段

### 9.7 模糊測試攻擊 (Fuzzing)

#### 9.7.1 攻擊原理

發送大量畸形或隨機的 Modbus 封包來測試系統穩定性，尋找潛在漏洞。

#### 9.7.2 攻擊範例

**隨機位元組**：

```
A3 7F 9B 2C E5 18 94 66 7A 3E F2 89 C4 51 D7 0B
```

**畸形封包結構**：

```
00 01 00 00 00 06 01 FF 00 00 00 00 00 00 00 00
                   ↑
              無效功能碼 (0xFF)
```

**極端數值**：

```
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
```

#### 9.7.3 攻擊效果

- 發現零日漏洞
- 系統當機
- 記憶體洩漏
- 異常行為

#### 9.7.4 防護措施

- 輸入驗證
- 異常處理
- 健全性檢查
- 定期安全測試

### 9.8 攻擊檢測和防護建議

#### 9.8.1 監控指標

- 異常大小的封包
- 高頻率的請求
- 無效的功能碼
- 不尋常的 Transaction ID 模式
- 連線異常

#### 9.8.2 防護策略

1. **網路層防護**

   - 防火牆規則
   - 入侵偵測系統 (IDS)
   - 流量分析

2. **應用層防護**

   - 輸入驗證
   - 存取控制
   - 稽核日誌

3. **系統層防護**
   - 定期更新
   - 權限最小化
   - 系統監控

## 10. 安全考量

### 10.1 網路安全

- Modbus TCP 本身沒有加密機制
- 建議在 VPN 或專用網路上使用
- 考慮使用防火牆限制存取

### 10.2 授權控制

- 實作適當的存取控制
- 監控和記錄 Modbus 操作
- 定期檢查設備配置

## 11. 工具和測試

### 11.1 常用工具

- **Wireshark**: 網路封包分析
- **ModbusPoll**: Modbus 客戶端測試工具
- **ModbusSlave**: Modbus 伺服器模擬器

### 11.2 測試建議

- 使用本地迴路測試基本功能
- 測試各種錯誤情況
- 驗證資料完整性
- 效能壓力測試

這份文件涵蓋了 Modbus TCP 的核心概念和實際應用，可以作為開發和除錯的參考指南。
